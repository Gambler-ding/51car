C51 COMPILER V9.57.0.0   UART                                                              03/31/2023 21:50:02 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: D:\keil\keil51\C51\BIN\C51.EXE USER\UART\uart.C OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Listings;.\USER;.
                    -\USER\OLED;.\USER\MOTOR;.\USER\TIMER;.\USER\ADC;.\USER\UART;.\USER\EEPROM;.\USER\ACTION;.\USER\UART) DEBUG OBJECTEXTEND 
                    -PRINT(.\Listings\uart.lst) OBJECT(.\Objects\uart.obj)

line level    source

   1          #include "stc15w4k.h"
   2          #include "uart.h"
   3          #include <intrins.h>
   4          /*----------------series define------------------------------*/
   5          
   6          /*定时器3用作串口3的波特率发生器,定时器4用作串口4的波特率发生器*/
   7          //#define FOSC 11059200L          //系统频率
   8          #define FOSC 24000000L //18432000L
   9          #define BAUD 115200               //串口波特率
  10          #define NONE_PARITY     0       //无校验
  11          #define ODD_PARITY      1       //奇校验
  12          #define EVEN_PARITY     2       //偶校验
  13          #define MARK_PARITY     3       //标记校验
  14          #define SPACE_PARITY    4       //空白校验
  15          #define PARITYBIT EVEN_PARITY    //定义校验位
  16          
  17          #define S3RI  0x01              //S3CON.0
  18          #define S3TI  0x02              //S3CON.1
  19          #define S3RB8 0x04              //S3CON.2
  20          #define S3TB8 0x08              //S3CON.3
  21          #define S3_S0 0x02              //P_SW2.1
  22          
  23          #define S4RI  0x01              //S4CON.0
  24          #define S4TI  0x02              //S4CON.1
  25          #define S4RB8 0x04              //S4CON.2
  26          #define S4TB8 0x08              //S4CON.3
  27          #define S4_S0 0x04              //P_SW2.2
  28          
  29          u8 bdata UartFlag;
  30          sbit Uart1BusyStatus = UartFlag ^ 0;
  31          sbit Uart2BusyStatus = UartFlag ^ 1;
  32          sbit Uart3BusyStatus = UartFlag ^ 2;
  33          sbit Uart4BusyStatus = UartFlag ^ 3;
  34          sbit UartFirstByte   = UartFlag ^ 4;
  35          sbit HostCommand     = UartFlag ^ 5;
  36          
  37          u8 data UART_cnt;
  38          u8 idata UARTbuffer[10];    /*10byte*/
  39          
  40          sbit Uart1RXD         = P3 ^ 0;    /*PIN13,??1??*/
  41          sbit Uart1TXD         = P3 ^ 1;    /*PIN14,??1??*/
  42          
  43          void uartDelayMs( u16 delay_time)
  44          {
  45   1      u16 delay_cnt;
  46   1      while(delay_time--)
  47   1             {
  48   2             for(delay_cnt=0;delay_cnt<200;delay_cnt++)
  49   2                   {
  50   3                   _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_
             -();
  51   3                   _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_
             -();
C51 COMPILER V9.57.0.0   UART                                                              03/31/2023 21:50:02 PAGE 2   

  52   3                   _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_
             -();
  53   3                   _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_
             -();
  54   3                   _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_
             -();
  55   3                   _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_
             -();
  56   3                   }
  57   2             _nop_();
  58   2             }
  59   1      _nop_();
  60   1      }
  61          /*----------------------------------------------------------------------------------*/
  62          void UART1(void) interrupt 4           /*中断接受数据*/
  63          {
  64   1              u8 character;
  65   1              RI = 0;character = SBUF;
  66   1      
  67   1              if(UartFirstByte == 1)   {UARTbuffer[UART_cnt++] = character; }
  68   1      
  69   1              if(character==0xaa)      {UartFirstByte = 1;UART_cnt = 0;}
  70   1      
  71   1              if(character==0xbb)      {UartFirstByte = 0;HostCommand = 1;}
  72   1      
  73   1      }
  74          
  75          void UART1send_Abyte(u8 character)      /*发送u8数据*/
  76          {
  77   1              ES = 0;                                                 /*关闭串口保证设置*/
  78   1              SBUF = character;                               /*给SBUF赋值*/
  79   1              while(!TI) ;                                    /*有中断时才可以运行*/
  80   1              TI = 0;                                                 /*中断TI请求开启*/
  81   1              ES = 1;                                                 /*开启串口保证设置*/
  82   1              uartDelayMs(1);
  83   1      }
  84          void UART1send_AString(u8 *p)
  85          {
  86   1              while(*p)
  87   1              {
  88   2                      UART1send_Abyte(*p);
  89   2                      p++;
  90   2              }
  91   1      }
  92          void Uart1Init(void)            //9600bps@24MHz
  93                  {
  94   1              SCON = 0x50;            //8位数据,可变波特率
  95   1              AUXR |= 0x40;           //定时器时钟1T模式
  96   1              AUXR &= 0xFE;           //串口1选择定时器1为波特率发生器
  97   1              TMOD &= 0x0F;           //设置定时器模式
  98   1              TL1 = 0x8F;                     //设置定时初始值
  99   1              TH1 = 0xFD;                     //设置定时初始值
 100   1              ET1 = 0;                        //禁止定时器中断
 101   1              TR1 = 1;                        //定时器1开始计时
 102   1              UartFirstByte = 0;
 103   1              ES = 1;
 104   1              }
 105          
 106           /*-----------------------------------------------------------------------*/     
 107                
 108          
 109          void Uart3( void ) interrupt 17       /*------------UART3 中断服务程序----------------------*/
C51 COMPILER V9.57.0.0   UART                                                              03/31/2023 21:50:02 PAGE 3   

 110              {
 111   1          if (S3CON & S3RI)
 112   1             {
 113   2              S3CON &= ~S3RI;         //清除S3RI位
 114   2             }
 115   1          if (S3CON & S3TI)
 116   1             {
 117   2              S3CON &= ~S3TI;         //清除S3TI位
 118   2              Uart3BusyStatus = 0;               //清忙标志
 119   2             }
 120   1          }
 121          
 122          
 123          void Uart3SendData(u8 dat)      /*---------------发送串口数据--------------------------*/
 124          {
 125   1          while (Uart3BusyStatus);               //等待前面的数据发送完成
 126   1          ACC = dat;                  //获取校验位P (PSW.0)
 127   1          if (P)                      //根据P来设置校验位
 128   1          {
 129   2      #if (PARITYBIT == ODD_PARITY)
                      S3CON &= ~S3TB8;        //设置校验位为0
              #elif (PARITYBIT == EVEN_PARITY)
 132   2              S3CON |= S3TB8;         //设置校验位为1
 133   2      #endif
 134   2          }
 135   1          else
 136   1          {
 137   2      #if (PARITYBIT == ODD_PARITY)
                      S3CON |= S3TB8;         //设置校验位为1
              #elif (PARITYBIT == EVEN_PARITY)
 140   2              S3CON &= ~S3TB8;        //设置校验位为0
 141   2      #endif
 142   2          }
 143   1          Uart3BusyStatus = 1;
 144   1      //    S3BUF = ACC;                //写数据到UART2数据寄存器20200625
 145   1      
 146   1      
 147   1      //    if (S3CON & S3TI)
 148   1      //        {
 149   1      //        S3CON &= ~S3TI;         //清除S3TI位
 150   1      //        }
 151   1      
 152   1          S3BUF = dat;
 153   1      
 154   1      //    while(S3CON & S3TI) ;
 155   1      //    S3CON &= ~S3TI;         //清除S3TI位
 156   1      }
 157          void Uart3Command( u8 *p)
 158              {
 159   1          while(*p != '\0' )
 160   1              {
 161   2              Uart3SendData( *p);_nop_();uartDelayMs(1);
 162   2      
 163   2              p ++;
 164   2              }
 165   1          Uart3SendData(0x0d);_nop_();uartDelayMs(1);Uart3SendData(0x0a);_nop_();uartDelayMs(1);
 166   1          }
 167          
 168          void InitUart3(void)      /*----------------初始化UART3----------------------*/
 169              {
 170   1      //P_SW2 &= ~S3_S0;_nop_();            //S3_S0=0 (P0.0/RxD3, P0.1/TxD3)
 171   1      P_SW2 |= S3_S0;_nop_();             //S3_S0=1 (P5.0/RxD3_2, P5.1/TxD3_2)
C51 COMPILER V9.57.0.0   UART                                                              03/31/2023 21:50:02 PAGE 4   

 172   1      
 173   1      #if (PARITYBIT == NONE_PARITY)
                  S3CON = 0x50;_nop_();               //8位可变波特率
              
              #elif (PARITYBIT == ODD_PARITY) || (PARITYBIT == EVEN_PARITY) || (PARITYBIT == MARK_PARITY)
 177   1          S3CON = 0xda;_nop_();               //9位可变波特率,校验位初始为1
 178   1      #elif (PARITYBIT == SPACE_PARITY)
                  S3CON = 0xd2;_nop_();               //9位可变波特率,校验位初始为0
              #endif
 181   1      
 182   1          T3L = (65536 - (FOSC/4/BAUD));_nop_();   //设置波特率重装值
 183   1          T3H = (65536 - (FOSC/4/BAUD))>>8;_nop_();
 184   1      
 185   1          T4T3M |= 0x02;_nop_();              //定时器3为1T模式
 186   1          T4T3M |= 0x08;_nop_();              //定时器3开始计时
 187   1      
 188   1          IE2 = 0x08;_nop_();                 //使能串口3中断
 189   1          }
 190          
 191          /*----------------UART3 程序over----------------------*/
 192          
 193          /*----------------UART4 程序--------------------------*/
 194          void Uart4() interrupt 18
 195              {
 196   1          if (S4CON & S4RI)
 197   1              {
 198   2              S4CON &= ~S4RI;         //??S4RI?
 199   2              }
 200   1          if (S4CON & S4TI)
 201   1              {
 202   2              S4CON &= ~S4TI;         //??S4TI?
 203   2              Uart4BusyStatus = 0;               //????
 204   2              }
 205   1          }
 206          
 207          
 208          void Uart4SendData(u8 dat)
 209          {
 210   1          while (Uart4BusyStatus);               //???????????
 211   1          ACC = dat;                  //?????P (PSW.0)
 212   1          if (P)                      //??P??????
 213   1          {
 214   2      #if (PARITYBIT == ODD_PARITY)
                      S4CON &= ~S4TB8;        //??????0
              #elif (PARITYBIT == EVEN_PARITY)
 217   2              S4CON |= S4TB8;         //??????1
 218   2      #endif
 219   2          }
 220   1          else
 221   1          {
 222   2      #if (PARITYBIT == ODD_PARITY)
                      S4CON |= S4TB8;         //??????1
              #elif (PARITYBIT == EVEN_PARITY)
 225   2              S4CON &= ~S4TB8;        //??????0
 226   2      #endif
 227   2          }
 228   1          Uart4BusyStatus = 1;
 229   1          S4BUF = ACC;                //????UART4?????
 230   1      }
 231          
 232          
 233          void Uart4SendString(char *s)
C51 COMPILER V9.57.0.0   UART                                                              03/31/2023 21:50:02 PAGE 5   

 234          {
 235   1          while (*s)                  //?????????
 236   1          {
 237   2              Uart4SendData(*s++);uartDelayMs(10);
 238   2          }
 239   1      }
 240          
 241          void InitUart4(void)
 242          {
 243   1      //P_SW2 &= ~S4_S0;            //S4_S0=0 (P0.2/RxD4, P0.3/TxD4)
 244   1      P_SW2 |= S4_S0;             //S4_S0=1 (P5.2/RxD4_2, P5.3/TxD4_2)
 245   1      
 246   1      #if (PARITYBIT == NONE_PARITY)
                  S4CON = 0x50;               //8??????
              #elif (PARITYBIT == ODD_PARITY) || (PARITYBIT == EVEN_PARITY) || (PARITYBIT == MARK_PARITY)
 249   1          S4CON = 0xda;               //9??????,??????1
 250   1      #elif (PARITYBIT == SPACE_PARITY)
                  S4CON = 0xd2;               //9??????,??????0
              #endif
 253   1      
 254   1          T4L = (65536 - (FOSC/4/BAUD));   //????????
 255   1          T4H = (65536 - (FOSC/4/BAUD))>>8;
 256   1          T4T3M |= 0x20;              //???4?1T??
 257   1          T4T3M |= 0x80;              //???4????
 258   1          IE2 = 0x10;                 //????4??
 259   1      
 260   1      }
 261          /*----------------UART4 程序over----------------------*/
 262          
 263          
 264          
 265          
 266          
 267          
 268          
 269          
 270          
 271          
 272          
 273          
 274          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    454    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       3
   IDATA SIZE       =     10    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
