C51 COMPILER V9.57.0.0   ADC                                                               03/27/2023 21:48:32 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Objects\adc.obj
COMPILER INVOKED BY: D:\keil\keil51\C51\BIN\C51.EXE USER\adc\adc.C OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Listings;.\USER;.\U
                    -SER\OLED;.\USER\MOTOR;.\USER\TIMER;.\USER\ADC;.\USER\UART;.\USER\EEPROM) DEBUG OBJECTEXTEND PRINT(.\Listings\adc.lst) OB
                    -JECT(.\Objects\adc.obj)

line level    source

   1          
   2          /*signal INPUT PIN is 5,ADC4   */
   3          #include "stc15w4k.h"
   4          #include "oled.h"
   5          
   6          #include "adc.h"
   7          #include "timer.h"
   8          #include <intrins.h>
   9          
  10          #define  uchar unsigned char
  11          #define  uint unsigned int
  12          
  13          #define ADC_POWER 0x80   /*ADC power control bit*/
  14          #define ADC_FLAG  0x10   /*ADC complete flag*/
  15          #define ADC_START 0x08   /*ADC start control bit*/
  16          #define ADC_SPEEDHH 0x60 /*90 clocks*/
  17          #define ADC_SPEEDH  0x40 /*180 clocks*/
  18          #define ADC_SPEEDL  0x20 /*360 clocks*/
  19          #define ADC_SPEEDLL 0x00 /*540 clocks*/
  20          uchar idata asc_buffer[10];
  21          
  22          unsigned char bdata AdcFlag;  
  23          uint data AdcValue;                       
  24          sbit AdcOver = AdcFlag ^ 0;
  25          
  26          void ADC_isr(void) interrupt 5  using 1  /*get ADC result ,中断向量地址002BH*/
  27               {
  28   1           ADC_CONTR &= ~ADC_FLAG;   /*clear ADC complte flag*/
  29   1               AdcValue = ADC_RES;AdcValue &= 0x0003;AdcValue *= 256;
  30   1           AdcValue += ADC_RESL ;
  31   1      
  32   1           AdcOver = 1;
  33   1           }
  34          
  35          void StartADC( uchar ADC_ch)
  36               {
  37   1           ADC_CONTR = ADC_POWER | ADC_SPEEDHH | ADC_START | ADC_ch;
  38   1           }
  39          
  40          void initialADC( uchar ADC_ch)
  41          {
  42   1      
  43   1      /*--------端口模式设置-------*/
  44   1      /*  PxM1  PxM0       模式    */
  45   1      /*    0     0     准双向口   */
  46   1      /*    0     1     强推挽输出 */
  47   1      /*    1     0     高阻输入   */
  48   1      /*    1     1     开漏输出   */
  49   1      /*---------------------------*/
  50   1      
  51   1               switch(ADC_ch)
  52   1                      {
  53   2                      case 0:P1M1 = 0x01;P1M0 = 0x00;break; /*P1.7-P1.1准双向口,P1.0高阻输入*/
C51 COMPILER V9.57.0.0   ADC                                                               03/27/2023 21:48:32 PAGE 2   

  54   2                      case 1:P1M1 = 0x02;P1M0 = 0x00;break; /*P1.7-P1.2准双向口,P1.1高阻输入,P1.0准双向口*/
  55   2                      case 2:P1M1 = 0x04;P1M0 = 0x00;break; /*P1.7-P1.3准双向口,P1.2高阻输入,P1.1-P1.0准双向口*/
  56   2                      case 3:P1M1 = 0x08;P1M0 = 0x00;break; /*P1.7-P1.4准双向口,P1.3高阻输入,P1.2-P1.0准双向口*/
  57   2                      case 4:P1M1 = 0x10;P1M0 = 0x00;break; /*P1.7-P1.5准双向口,P1.4高阻输入,P1.3-P1.0准双向口*/
  58   2                      case 5:P1M1 = 0x20;P1M0 = 0x00;break; /*P1.7-P1.6准双向口,P1.5高阻输入,P1.4-P1.0准双向口*/
  59   2                      case 6:P1M1 = 0x40;P1M0 = 0x00;break; /*P1.7准双向口,P1.6高阻输入,P1.5-P1.0准双向口*/
  60   2                      case 7:P1M1 = 0x80;P1M0 = 0x00;break; /*P1.7高阻输入,P1.6-P1.0准双向口*/
  61   2                      default:P1M1 = 0xff;P1M0 = 0x00;          /*P1.7-P1.0高阻输入*/
  62   2                      }
  63   1           P1 = 0xff;     /*20190831*/
  64   1               switch(ADC_ch)
  65   1                      {
  66   2                      case 0:P1ASF = 0x01;break; /*P1.0口作为模拟输入口*/
  67   2                      case 1:P1ASF = 0x02;break; /*P1.1口作为模拟输入口*/
  68   2                      case 2:P1ASF = 0x04;break; /*P1.2口作为模拟输入口*/
  69   2                      case 3:P1ASF = 0x08;break; /*P1.3口作为模拟输入口*/
  70   2                      case 4:P1ASF = 0x10;break; /*P1.4口作为模拟输入口*/
  71   2                      case 5:P1ASF = 0x20;break; /*P1.5口作为模拟输入口*/
  72   2                      case 6:P1ASF = 0x40;break; /*P1.6口作为模拟输入口*/
  73   2                      case 7:P1ASF = 0x80;break; /*P1.7口作为模拟输入口*/
  74   2                      default:P1ASF = 0xff;      /*P1.7-P1.0作为模拟输入口*/
  75   2                      }
  76   1      
  77   1      //     ADC_RES =0;
  78   1           ADC_CONTR = ADC_POWER | ADC_SPEEDHH | ADC_START | ADC_ch;   /*enable ADC*/
  79   1           CLK_DIV |= 0x20;      /*ADRJ=1,2bit+8bit ADC数据格式*/
  80   1           EADC = 1;  /*ADC转换中断 允许*/
  81   1               AdcOver = 0;
  82   1      
  83   1      }
  84          void f_to_a(float x )
  85                  {
  86   1              unsigned char data i,j,p;
  87   1              unsigned char data user_buffer[8];
  88   1              unsigned long data long_register;
  89   1              p=0;
  90   1              if(x < 0.0) {asc_buffer[p] = '-';x *= -1;}
  91   1              else         {asc_buffer[p] = '+';}
  92   1      
  93   1              p++;
  94   1      
  95   1              long_register=x;
  96   1      
  97   1              x=x-long_register;
  98   1      
  99   1              j=0;
 100   1              while(1)
 101   1                      {
 102   2                      user_buffer[j]=long_register%10;
 103   2      
 104   2                      if(long_register == 0)
 105   2                             {
 106   3                             if(j==0)  { j++;}
 107   3                             break;
 108   3                             }
 109   2      
 110   2                      long_register /= 10;
 111   2                       j++;
 112   2                      }
 113   1              for(i=j;i<8;i++)
 114   1                      {
 115   2                      user_buffer[i]=x*10;
C51 COMPILER V9.57.0.0   ADC                                                               03/27/2023 21:48:32 PAGE 3   

 116   2                      x *= 10;
 117   2                      x -= user_buffer[i];
 118   2                      }
 119   1              for(i=0;i<j;i++)
 120   1                      {
 121   2                      asc_buffer[p] = user_buffer[j-i-1]+'0';
 122   2                      p++;
 123   2                      }
 124   1              asc_buffer[p] = '.';p++;
 125   1              for(i=j;i<8;i++)
 126   1                      {
 127   2                      asc_buffer[p] = user_buffer[i]+'0';p++;
 128   2                      }
 129   1               }
 130          
 131          void power_show()
 132          {
 133   1                      u16 idata powerAdcBuffer[8];
 134   1                  u8 cnt_i=0xff,AdcCounter = 0;
 135   1                      float floatReg=0.0,powerVolts;
 136   1                      initialADC( 7 );
 137   1                      StartADC( 7 );
 138   1                      while ( AdcOver == 0 )  {_nop_();}
 139   1                      AdcOver = 0;
 140   1                      powerAdcBuffer[AdcCounter] = AdcValue;
 141   1                      
 142   1                      AdcValue = 0;
 143   1              for(cnt_i=0;cnt_i<8;cnt_i++)
 144   1                              {
 145   2                              AdcValue += powerAdcBuffer[cnt_i];
 146   2                              }
 147   1                      AdcValue /= 8; 
 148   1                      floatReg = AdcValue;floatReg *= 5;floatReg /= 512;
 149   1      
 150   1                      powerVolts = floatReg;
 151   1                      f_to_a(floatReg);
 152   1                for(cnt_i=1;cnt_i<5;cnt_i++)
 153   1                              {
 154   2                              OLED_ShowChar(cnt_i*8,6,asc_buffer[cnt_i],16);DelayMs(1);
 155   2                              }
 156   1                      _nop_();
 157   1                      OLED_ShowString(40,6,"V/",16);
 158   1      
 159   1                      
 160   1                      AdcCounter ++;AdcCounter &= 0x07;
 161   1                      //UART1send_Abyte(AdcCounter + '0');UART1send_Abyte(0x0d);UART1send_Abyte(0x0a);
 162   1      }
 163          
 164          
 165          
 166          
 167          
 168          
 169          
 170          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    874    ----
   CONSTANT SIZE    =      3    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.57.0.0   ADC                                                               03/27/2023 21:48:32 PAGE 4   

   DATA SIZE        =      3      29
   IDATA SIZE       =     10      16
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
